
class playerStatus : inventory {
	
	default {
		
		inventory.amount 1;
		inventory.maxamount 6;
		+INVENTORY.PERSISTENTPOWER;
	}
}

class changeStatus : inventory abstract {
	
	default {
		
		inventory.amount 1;
		inventory.maxamount 1;
		+INVENTORY.PERSISTENTPOWER;
	}
}

class enterEva00 : changeStatus {}
class enterEva01 : changeStatus {}
class enterEva02 : changeStatus {}
class playChild0 : changeStatus {}
class playChild1 : changeStatus {}
class playChild2 : changeStatus {}

class atfieldactivated : inventory {
	
	default {
		
		inventory.amount 1;
		inventory.maxamount 1;
		+INVENTORY.PERSISTENTPOWER;
	}
}

struct playerProperties {
	
	string soundclass;
	int mass;
	int air;
	int viewh;
	int attackz;
	double friction;
	double fm1;
	double fm2;
	double sm1;
	double sm2;
	double jumpz;
	double viewbob;
	double fallingdmg;
	bool gib;
	double syncfactor;
}


extend class evangelionPlayer {
	
	// Stores player properties for each class.
	playerProperties PP[6];
	
	// Initializes properties to default values
	override void PostBeginPlay () {
		
		super.PostBeginPlay();
		
		if (getAge() < 1) {
			
			changeClass(4); //Set pilot 1 as default start;
			
			for (int i = 1; i <= PP.size(); i++)
				setDefaultProperties(i);
		}
	}
	
	void setDefaultProperties (int classid) {
		
		playerProperties p;
		
		switch (classid) {
			case 1: p.soundclass = "eva01"; p.mass = 6000; p.air = 0; p.viewh = 56; p.attackz = 25; p.friction = 1.05; p.fm1 = 2.0; p.fm2 = 2.4; p.sm1 = 1.4; p.sm2 = 0.4; p.jumpz = 15.0; p.viewbob = 1.2; p.fallingdmg = 0.0; p.gib = false; break;
			case 2: p.soundclass = "eva01"; p.mass = 6000; p.air = 0; p.viewh = 56; p.attackz = 25; p.friction = 1.05; p.fm1 = 2.0; p.fm2 = 2.4; p.sm1 = 1.4; p.sm2 = 0.4; p.jumpz = 15.0; p.viewbob = 1.2; p.fallingdmg = 0.0; p.gib = false; break;
			case 3: p.soundclass = "eva01"; p.mass = 6000; p.air = 0; p.viewh = 56; p.attackz = 25; p.friction = 1.05; p.fm1 = 2.0; p.fm2 = 2.4; p.sm1 = 1.4; p.sm2 = 0.4; p.jumpz = 15.0; p.viewbob = 1.2; p.fallingdmg = 0.0; p.gib = false; break;
			case 4: p.soundclass = "shinji"; p.mass = 90; p.air = 5; p.viewh = 40; p.attackz = 16; p.friction = 1.0; p.fm1 = 0.5; p.fm2 = 0.7; p.sm1 = 0.4; p.sm2 = 0.5; p.jumpz = 8.0; p.viewbob = 0.1; p.fallingdmg = 1.0; p.gib = true; break;
			case 5: p.soundclass = "shinji"; p.mass = 90; p.air = 5; p.viewh = 40; p.attackz = 16; p.friction = 1.0; p.fm1 = 0.5; p.fm2 = 0.7; p.sm1 = 0.4; p.sm2 = 0.5; p.jumpz = 8.0; p.viewbob = 0.1; p.fallingdmg = 1.0; p.gib = true; break;
			case 6: p.soundclass = "shinji"; p.mass = 90; p.air = 5; p.viewh = 40; p.attackz = 16; p.friction = 1.0; p.fm1 = 0.5; p.fm2 = 0.7; p.sm1 = 0.4; p.sm2 = 0.5; p.jumpz = 8.0; p.viewbob = 0.1; p.fallingdmg = 1.0; p.gib = true; break;
		}
		
		//PP[classid-1] = p; // Why is this treated as a pointer?... (Struct assignment not implemented yet!)
		PP[classid-1].soundclass = p.soundclass;
		PP[classid-1].mass = p.mass;
		PP[classid-1].air = p.air;
		PP[classid-1].viewh = p.viewh;
		PP[classid-1].attackz = p.attackz;
		PP[classid-1].friction = p.friction;
		PP[classid-1].fm1 = p.fm1;
		PP[classid-1].fm2 = p.fm2;
		PP[classid-1].sm1 = p.sm1;
		PP[classid-1].sm2 = p.sm2;
		PP[classid-1].jumpz = p.jumpz;
		PP[classid-1].viewbob = p.viewbob;
		//PP[classid-1].fallingdmg = p.fallingdmg;
		PP[classid-1].gib = p.gib;
	}
	
	override void Tick () {
		
		super.Tick();
		
		refreshStatus();
		refreshProperties();
	}
	
	void refreshProperties () {
		
		// synchronization multiplier buff
		if (CountInv("playerStatus") < 4)
			PP[CountInv("playerStatus")].syncfactor = 1.0*CountInv("evasynchronization")/100.0;
		
		applyProperties(CountInv("playerStatus"));
	}
	
	// Detects if we want to change player class and acts
	void refreshStatus () {
		
		int newclass;
		
		if		(CountInv("enterEva00") > 0) { resetInv(); newclass = 1; A_GiveInventory("Eva01Fists", 1); A_GiveInventory("Eva01HandGun", 1); A_GiveInventory("evaenergy", 1800); A_GiveInventory("atfield", 500); }
		else if (CountInv("enterEva01") > 0) { resetInv(); newclass = 2; A_GiveInventory("Eva01Fists", 1); A_GiveInventory("Eva01HandGun", 1); A_GiveInventory("evaenergy", 3000); A_GiveInventory("atfield", 500); }
		else if (CountInv("enterEva02") > 0) { resetInv(); newclass = 3; A_GiveInventory("Eva01Fists", 1); A_GiveInventory("Eva01HandGun", 1); A_GiveInventory("evaenergy", 3000); A_GiveInventory("atfield", 500); }
		else if (CountInv("playChild0") > 0) { resetInv(); newclass = 4; A_SetInventory("evasynchronization", 100); }
		else if (CountInv("playChild1") > 0) { resetInv(); newclass = 5; A_SetInventory("evasynchronization", 100); }
		else if (CountInv("playChild2") > 0) { resetInv(); newclass = 6; A_SetInventory("evasynchronization", 100); }
		else return;
		
		changeClass(newclass);
	}
	
	void resetInv () {
		
		A_TakeInventory("enterEva00");
		A_TakeInventory("enterEva01");
		A_TakeInventory("enterEva02");
		A_TakeInventory("playChild0");
		A_TakeInventory("playChild1");
		A_TakeInventory("playChild2");
		
		A_TakeInventory("Eva01Fists");
		A_TakeInventory("Eva01HandGun");
		A_TakeInventory("Eva01AssaultRifle");
		A_TakeInventory("Bullets");
		A_TakeInventory("HeavyBullets");
		
		A_TakeInventory("evaenergy");
		//A_TakeInventory("evasynchronization");
		A_TakeInventory("atfield");
	}
	
	void applyProperties (int id) {
		
		double multiplier;
		
		// if we're in pilot form, don't use synchronization
		if (CountInv("playerStatus") > 3)
			multiplier = 1.0;
		// if synchronization is 100% or greater, slow the multiplier increase even more
		else if (PP[id].syncfactor >= 1.0)
			multiplier = (((PP[id].syncfactor-1.0)/16.0)+1.0);
		// if synchronization is 50% or greater, slow the multiplier increase
		else if (PP[id].syncfactor >= 0.5)
			multiplier = 0.2 + (((PP[id].syncfactor-0.5)/4.0)+0.5);
		// if synchronization is less than 2%, stop.
		else if (PP[id].syncfactor <= 0.02)
			multiplier = 0;
		else
			multiplier = 0.2 + PP[id].syncfactor;
		
		//A_SetMugshotState("E01");
		//face = "E01";
		mass = PP[id].mass;
		aircapacity = PP[id].air;
		viewheight = PP[id].viewh;
		attackzoffset = PP[id].attackz;
		friction = PP[id].friction;
		
		forwardmove1 = PP[id].fm1 * multiplier;
		forwardmove2 = PP[id].fm2 * multiplier;
		sidemove1 = PP[id].sm1 * multiplier;
		sidemove2 = PP[id].sm2 * multiplier;
		
		// if we're in an evaunit, and synchronization is less than 30%, disable jumping
		if (CountInv("playerStatus") <= 3 && PP[id].syncfactor < 0.3)
			jumpz = 0;
		else
			jumpz = PP[id].jumpz * multiplier;
		
		viewbob = PP[id].viewbob * multiplier;
		//damagefactor "falling" = PP[id].fallingdmg;
		bDONTGIB = PP[id].gib;
	}
	
	void changeClass (int classid) {
		
		A_SetInventory("playerStatus", classid);
		
		applyProperties(classid);
	}
	
	override int DamageMobj (Actor inflictor, Actor source, int damage, Name mod, int flags, double angle) {
		
		// The synchronization is reduced by half of the damage recieved.
		A_TakeInventory("evasynchronization", max(1,damage*0.2));
		
		return super.DamageMobj(inflictor, source, max(1,damage*0.4), mod, flags, angle);
	}
	
	override void FireWeapon (State stat) {
		
		// If synchronization is less than 2%, disable shooting
		if (CountInv("evasynchronization") < 2)
			return;
		
		super.FireWeapon(stat);
	}
	
	void EvaUnitRestore (void) {
		
		// Skip if we're not in a evaunit.
		if (CountInv("playerStatus") > 3)
			return;
		
		// Restore synchronization every 8 seconds when standing still.
		if (restCD++ > 70 && CountInv("evasynchronization") < 100) {
			
			restCD = 0;
			A_StartSound("EvaDoom/EvaUnit/Eva01/Fear");
			A_GiveInventory("evasynchronization", 10);
		}
		
		// Give regeneration when at 200% sync or more (Berserk)
		if (health < 50 && CountInv("evasynchronization") >= 200)
			A_GiveInventory("health", 1);
	}
}