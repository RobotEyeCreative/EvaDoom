#library "npclib"
#include "zcommon.acs"
#import "..\mathlib.acs"
#import "convlib.acs"

// Each NPC has an identificative tag starting from 500! (Up to MaxNPCS)
// The id is defined as the doomid order as specified in mapinfo.

#libdefine NPCTagStart 500
#libdefine NPCEvaUnits 3
#libdefine NPCEva00 1
#libdefine NPCEva01 2
#libdefine NPCEva02 3
#libdefine NPCRei 4
#libdefine NPCShinji 5
#libdefine NPCAsuka 6
#libdefine NPCMisato 7

#include "txtdb.acs"

// ------------- "Exploration" functions, used to print single comment NPC text lines.

Function str GetExplorationMssg (int who, int index) {

	int npcn = max(0, who-NPCTagStart);
	
	return NpcExploration[npcn][index];
}

Function void PrintNpcExploration (int who, int textid, bool own) {

	GiveInventory("playerConversation", 3);
	
	SetFont("VARELA");

	if (own)
		HudMessage(l:GetExplorationMssg(who, textid); HUDMSG_TYPEON, 1, CR_WHITE, -0.2, -0.7, 1.0, 0.05, 1.0);
	else
		HudMessage(l:GetExplorationMssg(who, textid); HUDMSG_TYPEON, 1, CR_CYAN, -0.2, -0.7, 1.0, 0.05, 1.0);
}

Function void PlayerInspection (int who, int txtid) {

	int identity = CheckInventory("playerIdentity");
	bool own = true;

	if (who > 0) {

		if (identity != who)
			own = false;

		if (who > NPCEvaUnits)
			PrintNpcExploration(NPCTagStart+who-1-NPCEvaUnits, txtid, own);
		else
			PrintNpcExploration(NPCTagStart+who-1, txtid, own);

	} else {

		if (identity > NPCEvaUnits)
			PrintNpcExploration(NPCTagStart+identity-NPCEvaUnits, txtid, own);
		else
			PrintNpcExploration(NPCTagStart+identity, txtid, own);
	}
}

// ------------- Conversation functions.

Function str GetNpcPotrait (int who) {
	
	int npcn = max(0, who-NPCTagStart);
	
	str result = StrParam(s:"graphics/npcs/", s:NpcPotraits[npcn][NpcStateEmotion[npcn][NpcStatus[npcn]]], s:".png");
	
	return result;
}

Function str GetNpcName (int who) {
	
	int npcn = max(0, who-NPCTagStart);
	
	return NpcNames[npcn][0];
}

/* Had to make a new function because thing specials only let me use 3 parameters...
Even when the function itself lets me to declare about 5 parameters and use them on ACS. */

Function void EditNpcResponse (int who, int value, int state, int index) {

	int npcn = max(0, who-NPCTagStart);
	
	// To edit a value in a specific place you must specify a value, index and state greater than -1 to take effect.
	if ( (value > -1 && value < MaxQuestions) && (index > -1 && index < MaxResponses) && (state > -1 && state < MaxStates) )
		NpcResponsesIndex[npcn][state][index] = value;

}

/* This function searches the introduced response index and replaces it.
Executed from ACS. Useful when you want to make sure a determined response only is played once. */

Function void ReplaceNpcResponse (int who, int value, int newvalue) {

	int npcn = max(0, who-NPCTagStart);
	
	// To replace a value you must specify a value, and new value greater to -1 to take effect.
	if ( (value > -1 && value < MaxQuestions) && (newvalue > -1 && newvalue < MaxQuestions) )
		for (int y = 0; y < MaxStates; y++)
			for (int x = 0; x < MaxResponses; x++)
				if (NpcResponsesIndex[npcn][y][x] == value) NpcResponsesIndex[npcn][y][x] = newvalue;
	
}


Function int GetNpcNewState (int who, int response) {
	
	int npcn = max(0, who-NPCTagStart);
	
	// Search response position in current status.
	for (int i = 0; i < MaxResponses; i++)
		if (NpcResponsesIndex[npcn][NpcStatus[npcn]][i] == response)
			break;
			
	// Return the new state with response position in current status.
	return NpcStateResponses[npcn][NpcStatus[npcn]][i];
}

Function void ExecuteNpcConversation (int who, int start, int setState) {
	
	int npcn = max(0, who-NPCTagStart);
	
	// If we want to edit the actual conversation state. If not, use setState -1 to maintain current state.
	if (setState > -1 && setState < MaxStates) // Make sure the new state exists.
		NpcStatus[npcn] = setState;
	
	// Use start = 1 to start a conversation. You can use 0 if you only want to change the status nor index.
	if (start == 1) {
		
		// Print the npc message in the actual conversation status.
		PrintNPCMessage(NpcAnswers[npcn][NpcStatus[npcn]]);
		
		// Reset arrow position. (Goes to the first option.)
		PrintArrowConversation(666);
		
		// Count responses of the current status. i.e: (1 2 0 5 0 0 --> [3])
		int c = 0;
		for (int y = 0; y < MaxResponses; y++)
			if (NpcResponsesIndex[npcn][NpcStatus[npcn]][y] > 0)
				c++;
		
		// Send responses count.
		ResponsesBufferCount = c;
		
		// Clear memory.
		for (int i = 0; i < MaxResponses; i++)
			ResponsesBuffer[i] = 0;
		
		// Save the responses in memory in reversed order. i.e: (1 2 0 5 0 0 --> 5 2 1)
		int k = 0;
		while (y-- > 0)
			if (NpcResponsesIndex[npcn][NpcStatus[npcn]][y] > 0)
				ResponsesBuffer[k++] = NpcResponsesIndex[npcn][NpcStatus[npcn]][y];
		
		// Clear coordinates and ID's so new printed responses could spawn where they belong.
		ResetOptionsMessagesCoords();
		
		// Delete old responses.
		for (int z = 0; z < MaxResponses; z++)
			PrintOptionsMessages("");
		
		// Clear coordinates and ID's so new printed responses could spawn where they belong.
		ResetOptionsMessagesCoords();
		
		// Print responses. i.e: (1 2 0 5 0 0 --> print 5 2 1)
		for (int x = 0; x < ResponsesBufferCount; x++)
			PrintOptionsMessages(NpcQuestions[npcn][ResponsesBuffer[x]-1]);
	}
}




